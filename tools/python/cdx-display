#!/usr/bin/env python
##
# \file cdx-display.py
# \date April 4, 2012
# \author Frank Schubert
#
#   CDX Library
#
#   As part of
#
#   SNACS - The Satellite Navigation Radio Channel Simulator
#
#   Class to read continuous-delay CDX files.
#
#   Copyright (C) 2012-2013  F. M. Schubert
#
#   This program is free software: you can redistribute it and/or modify
#   it under the terms of the GNU General Public License as published by
#   the Free Software Foundation, either version 3 of the License, or
#   (at your option) any later version.
#
#   This program is distributed in the hope that it will be useful,
#   but WITHOUT ANY WARRANTY; without even the implied warranty of
#   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
#   GNU General Public License for more details.
#
#   You should have received a copy of the GNU General Public License
#   along with this program.  If not, see <http://www.gnu.org/licenses/>.

# Command line parameters:
# -f <file_name>: input CDX file

# initialization
import numpy as np
import h5py
import argparse
import os
import sys

from PySide import QtCore, QtGui
import matplotlib
import matplotlib.backend_bases
#from h5py._hl.base import ValueView

matplotlib.use('Qt4Agg')
matplotlib.rcParams['backend.qt4']='PySide'
import matplotlib.pyplot as plt
from matplotlib.backends.backend_qt4agg import (
     FigureCanvasQTAgg as FigureCanvas,
     NavigationToolbar2QT as NavigationToolbar)

import multiprocessing

#from cdx import CDXFiguresGenerator

import cdx.FiguresGenerator

# set matplotlib font size:
# global matplotlib settings (see http://matplotlib.org/users/customizing.html)
# set global matplotlib parameters:
params = {'legend.fontsize': 7,
          'font.size'   : 7,
          'font.family': 'sans-serif',
          'xtick.labelsize': 7,
          'ytick.labelsize': 7,
          'axes.labelsize': 7,
          'lines.linewidth': 1.0,
          'axes.linewidth': 0.5
#           'legend.linewidth': 0.5
        }
plt.rcParams.update(params)

class ChannelLink(QtGui.QWidget):
    def __init__(self, cdx_figures, link_name, enable_pdp, parent=None):
        QtGui.QWidget.__init__(self, parent)
        self.cdx_figures = cdx_figures
        self.enable_pdp = enable_pdp
        self.link_name = link_name

        # make a vboxlayout for each link:
        self.vbox = QtGui.QVBoxLayout()
        # top is QComboBox, below is HBoxLayout for all plots:
        self.combobox = QtGui.QComboBox()
        # insert all link names into combobox:
        link_names = self.cdx_figures.cdx_file.get_link_names()
        self.combobox.insertItems(0, link_names)
        # set current entry to link_name
        self.combobox.setCurrentIndex(link_names.index(self.link_name))

        self.combobox.currentIndexChanged.connect(self.combobox_index_changed)

        self.vbox.addWidget(self.combobox)

        self.hbox = QtGui.QHBoxLayout()
        self.vbox.addLayout(self.hbox)

        # the main layout for us:
        self.setLayout(self.vbox)

        # list of canvases that hols all figures:
        self.canvases = []

        # if we have discrete-delay data, we also display it:
        if  self.cdx_figures.cdd_enabled == True:
            # set span to 1 s or to length of file if it is smaller:
            self.cdd_span_s = self.cdx_figures.cdd_file.get_length_s()
            #if self.cdd_span_s > 1.0:
            #    self.cdd_span_s = 1.0

            self.cdd_length_s = self.cdx_figures.cdd_file.get_length_s()

        # if visualization is enabled, prepare list that holds QPixmap objects:
        if self.cdx_figures.visualization_enabled == True:
            # create QPixmap object if we have images of the scenery, i.e. visualization is enabled:
            if self.cdx_figures.visualization_enabled == True:
                self.scenery_label = QtGui.QLabel()
                self.hbox.addWidget(self.scenery_label)

        # create figure object for CIR figure:
        self.cir_figure = plt.figure(dpi=100)
        self.cir_ax = self.cir_figure.add_subplot(1, 1, 1)
        self.add_figure_to_canvas(self.cir_figure)

        if cdx_figures.cdd_enabled == True:
            self.cir_discr_figure = plt.figure(dpi=100)
            self.cir_discr_ax = self.cir_discr_figure.add_subplot(1, 1, 1)
            self.cir_discr_vline = self.cir_discr_ax.axvline(x=0, color='r')
            self.add_figure_to_canvas(self.cir_discr_figure)

            self.dds_figure = plt.figure(dpi=100)
            self.dds_ax = self.dds_figure.add_subplot(1, 1, 1)
            self.add_figure_to_canvas(self.dds_figure)

        # create figure object for power figure:
        self.power_figure = plt.figure(dpi=100)
        self.power_ax = self.power_figure.add_subplot(1, 1, 1)
        self.power_vline = self.power_ax.axvline(x=0, color='r')
        self.add_figure_to_canvas(self.power_figure)

        # create figure object for delay spread figure:
        self.delay_spread_figure = plt.figure(dpi=100)
        self.delay_spread_ax = self.delay_spread_figure.add_subplot(1, 1, 1)
        self.delay_spread_vline = self.delay_spread_ax.axvline(x=0, color='r')
        self.add_figure_to_canvas(self.delay_spread_figure)

        if self.enable_pdp == True:
            # create figure for power delay profile:
            self.pdp_figure = plt.figure(dpi=100)
            self.pdp_ax = self.pdp_figure.add_subplot(1, 1, 1)
            self.add_figure_to_canvas(self.pdp_figure)

        # add first scenery image:
        if self.cdx_figures.visualization_enabled == True:
            print 'displaying scenery image ', self.cdx_figures.get_scenery_image_for_time(self.link_name, 0)
            self.scenery_label.setPixmap(QtGui.QPixmap(self.cdx_figures.get_scenery_image_for_time(self.link_name, 0)).scaled(300, 300, QtCore.Qt.KeepAspectRatio))

        # start computation of these plots in parallel:
        pool = multiprocessing.Pool(processes=4)
        pool.apply_async(cdx_figures.make_cir_axes(self.cir_ax, self.link_name, 0))

        # add first CIR plot:
        if self.cdx_figures.cdd_enabled == True:
            start_time = 0
            length = self.cdd_span_s
            self.cir_discr_figure = self.cdx_figures.make_discr_cir_axes(self.cir_discr_ax, self.link_name, start_time, length)
            self.dds_figure = self.cdx_figures.make_delay_doppler_spectrum(self.dds_ax, self.link_name, start_time, length)

        # add first power plot:
        pool.apply_async(cdx_figures.make_power_axes(self.power_ax, self.link_name))

        # add delay spread plot:
        pool.apply_async(cdx_figures.make_delay_spread_axes(self.delay_spread_ax, self.link_name))

        if self.enable_pdp == True:
            # compute power-delay profiles:
            #im = cdx_figures.make_pdp_axes(self.pdp_axes[idx], link_name)
            pool.apply_async(cdx_figures.make_pdp_axes(self.pdp_ax, link_name, 10e-7, 10e0, self.pdp_figure))
            #self.pdp_axes[idx].xaxis.set_ticks_position('bottom')

        print 'joining processes...'
        pool.close()
        pool.join()

        print 'done.'

    def add_figure_to_canvas(self, fig):
        # add canvas for CIR to Layout:
        self.canvases.append(FigureCanvas(fig))
        #self.canvases[-1].setParent(self.main_frame)
        self.canvases[-1].setFocusPolicy(QtCore.Qt.StrongFocus)
        self.canvases[-1].setFocus()
#          self.mpl_toolbar = NavigationToolbar(self.canvases, self.main_frame)
#          self.canvases.mpl_connect('key_press_event', self.on_key_press)
        self.hbox.addWidget(self.canvases[-1])
#          self.hboxes[idx].addWidget(self.mpl_toolbar)

    def update(self, value, time):
        # update CIR plots:
        self.cir_ax.clear()
        self.cdx_figures.make_cir_axes(self.cir_ax, self.link_name, value)

        # update scenery image:
        if self.cdx_figures.visualization_enabled == True:
            print 'displaying scenery image ', self.cdx_figures.get_scenery_image_for_time(self.link_name, time)
            self.scenery_label.setPixmap(QtGui.QPixmap(self.cdx_figures.get_scenery_image_for_time(self.link_name, time)).scaled(300, 300, QtCore.Qt.KeepAspectRatio))

        # update discrete-delay CIR plots:
        if self.cdx_figures.cdd_enabled == True:
            start_time = time - self.cdd_span_s / 2.0
             # limit start time and length to file length:
            if start_time < 0:
                start_time = 0
            length = self.cdd_span_s
            if start_time + length > self.cdd_length_s:
                length = self.cdd_length_s - start_time #- 1.0 / self.cir_rate
            self.cdx_figures.make_discr_cir_axes(self.cir_discr_ax, self.link_name, start_time, length)
            self.cir_discr_vline.set_xdata(time)

            self.cdx_figures.make_delay_doppler_spectrum(self.dds_ax, self.link_name, start_time, length)

        # update vertical line in power plot:
        self.power_vline.set_xdata(time)

        # update vertical line in delay spread plot:
        self.delay_spread_vline.set_xdata(time)

        for canvas in self.canvases:
            canvas.draw()

    def combobox_index_changed(self, idx):
        self.link_name = self.combobox.itemText(idx)

##
# \brief Class to display a Window with a number of plots per link in a CDX file. A
# slider can be used to set the time for which the plots are supposed to be displayed.
#
# Data such as the channel impulse response for a specific time, the power and delay spreads
# over time, as well as the power-delay profile is displayed for each link in a CDX
# file.
#
class CDXDisplayWindows(QtGui.QMainWindow):
     def __init__(self, cdx_figures, enable_pdp, parent=None):
         QtGui.QMainWindow.__init__(self, parent)

         # read CDX file:
         self.cdx_figures = cdx_figures
         self.link_names = self.cdx_figures.cdx_file.get_link_names()
         self.nof_cirs = self.cdx_figures.cdx_file.get_nof_cirs()
         self.cir_rate = self.cdx_figures.cdx_file.get_cir_rate()

         # setup widgets:
         self.main_frame = QtGui.QWidget()

         self.vbox = QtGui.QVBoxLayout()
         self.main_frame.setLayout(self.vbox)
         self.setCentralWidget(self.main_frame)

         # label for the slider:
         self.t_label = QtGui.QLabel('t = ')
         self.vbox.addWidget(self.t_label)

         # the slider for the CIR number and time:
         self.sld = QtGui.QSlider(QtCore.Qt.Horizontal, self)
         self.sld.setMinimum(0)
         self.sld.setMaximum(self.nof_cirs - 1)
         self.sld.setFocusPolicy(QtCore.Qt.NoFocus)
         self.sld.setGeometry(30, 40, 100, 30)
         self.sld.valueChanged[int].connect(self.on_slider_change)
         self.vbox.addWidget(self.sld)

         #self.vbox.addLayout(self.hboxes[-1])

         self.on_draw()

         self.max_nof_links_to_show = 2
         if len(self.link_names) < self.max_nof_links_to_show:
             self.max_nof_links_to_show = len(self.link_names)

         self.link_layouts = []
         print 'showing ', self.max_nof_links_to_show, ' links.'
         for idx in np.arange(self.max_nof_links_to_show):
             self.link_layouts.append(ChannelLink(self.cdx_figures, self.link_names[idx], enable_pdp))
             self.vbox.addWidget(self.link_layouts[-1])

     def on_slider_change(self, value):
         time = value / self.cir_rate
         self.t_label.setText('CIR number: {}, t = {} s'.format(value, time))

         for link_layout in self.link_layouts:
             link_layout.update(value, time)

     def on_draw(self):
         #self.canvases.draw()
         pass

     def on_key_press(self, event):
         print('you pressed', event.key)
         # implement the default mpl key press events described at
         # http://matplotlib.org/users/navigation_toolbar.html#navigation-keyboard-shortcuts
         key_press_handler(event, self.canvases, self.mpl_toolbar)


if __name__ == '__main__':
     # parse command line arguments
     parser = argparse.ArgumentParser()
     parser.add_argument("-i", "--input", help="input CDX file", action="store")
     parser.add_argument("-p", "--no-pdp", help="disable power delay profile", action="store_true")
     args = parser.parse_args()

     if args.input == None:
         raise SystemExit("Error: no input file given (command line parameter -i is missing).")
     else:
         file_name = args.input

     if args.no_pdp == True:
         enable_pdp = False
     else:
         enable_pdp = True

     print 'multiprocessing.CPU_count():', multiprocessing.cpu_count()
     cdx_figures = cdx.FiguresGenerator.FiguresGenerator(args.input)

     app = QtGui.QApplication(sys.argv)
     form = CDXDisplayWindows(cdx_figures, enable_pdp)
     form.setWindowTitle('Channel Data Exchange (CDX): Display File')
     form.show()

     app.exec_()
